package com.nith.flex.portfolio.controller;

import java.io.IOException;
import java.util.List;

import org.springframework.core.io.Resource;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PatchMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

import com.nith.flex.portfolio.config.security.AuthUser;
import com.nith.flex.portfolio.dto.ProjectImageResponse;
import com.nith.flex.portfolio.service.FileStorageService;
import com.nith.flex.portfolio.service.ProjectImageService;

import jakarta.servlet.http.HttpServletRequest;
import lombok.RequiredArgsConstructor;

@RestController
@RequiredArgsConstructor
public class ProjectImageController {

	private final ProjectImageService projectImageService;
	private final FileStorageService fileStorageService;

	// Get all images (metadata) for a specific project
	@GetMapping("/api/projects/{projectId}/images")
	@PreAuthorize("permitAll()")
	public ResponseEntity<List<ProjectImageResponse>> getImagesForProject(@PathVariable Long projectId) {
		List<ProjectImageResponse> images = projectImageService.getImagesForProject(projectId);
		return ResponseEntity.ok(images);
	}

	// Endpoint to serve the actual image files (publicly accessible)
	@GetMapping("/api/files/{fileName:.+}") // :.+ allows for file extensions in the path variable
	@PreAuthorize("permitAll()")
	public ResponseEntity<Resource> downloadFile(@PathVariable String fileName, HttpServletRequest request)
			throws IOException {
		Resource resource = fileStorageService.loadFileAsResource(fileName);

		String contentType = null;
		try {
			// Try to determine file's content type
			contentType = request.getServletContext().getMimeType(resource.getFile().getAbsolutePath());
		} catch (IOException ex) {
			// Log the exception, fall back to default if not determinable
			// logger.info("Could not determine file type.");
		}

		// Fallback to default content type if type could not be determined
		if (contentType == null) {
			contentType = "application/octet-stream";
		}

		return ResponseEntity.ok().contentType(MediaType.parseMediaType(contentType))
				.header(HttpHeaders.CONTENT_DISPOSITION, "inline; filename=\"" + resource.getFilename() + "\"")
				.body(resource);
	}


	// Upload a new image to a project (owned by the authenticated user)
	@PostMapping("/api/projects/{projectId}/images")
	@PreAuthorize("@projectSecurity.isOwnerOrAdmin(#projectId)") // Reusing ProjectSecurity
	public ResponseEntity<ProjectImageResponse> uploadImage(@PathVariable Long projectId,
			@RequestParam("file") MultipartFile file, @RequestParam(value = "caption", required = false) String caption,
			@RequestParam(value = "orderIndex", required = false) Integer orderIndex,
			@RequestParam(value = "isFeatured", defaultValue = "false") Boolean isFeatured,
			Authentication authentication) {

		AuthUser userPrincipal = (AuthUser) authentication.getPrincipal();
		ProjectImageResponse uploadedImage = projectImageService.uploadImage(userPrincipal.getId(), projectId, file,
				caption, orderIndex, isFeatured);
		// The imageUrl in the response DTO will now be correctly generated by the
		return new ResponseEntity<>(uploadedImage, HttpStatus.CREATED);
	}

	// Update metadata for an existing image (must be owned by the user via project)
	@PatchMapping("/api/projects/{projectId}/images/{imageId}")
	@PreAuthorize("@projectSecurity.isOwnerOrAdmin(#projectId)")
	public ResponseEntity<ProjectImageResponse> updateImageMetadata(@PathVariable Long projectId,
			@PathVariable Long imageId, @RequestParam(value = "caption", required = false) String caption,
			@RequestParam(value = "orderIndex", required = false) Integer orderIndex,
			@RequestParam(value = "isFeatured", required = false) Boolean isFeatured, // Can be null for patch
			Authentication authentication) {

		AuthUser userPrincipal = (AuthUser) authentication.getPrincipal();
		ProjectImageResponse updatedImage = projectImageService.updateImageMetadata(userPrincipal.getId(), projectId,
				imageId, caption, orderIndex, isFeatured);
		return ResponseEntity.ok(updatedImage);
	}

	// Delete a specific image from a project (must be owned by the user)
	@DeleteMapping("/api/projects/{projectId}/images/{imageId}")
	@PreAuthorize("@projectSecurity.isOwnerOrAdmin(#projectId)")
	public ResponseEntity<Void> deleteImage(@PathVariable Long projectId, @PathVariable Long imageId,
			Authentication authentication) {
		AuthUser userPrincipal = (AuthUser) authentication.getPrincipal();
		projectImageService.deleteImage(userPrincipal.getId(), projectId, imageId);
		return ResponseEntity.noContent().build();
	}
}
